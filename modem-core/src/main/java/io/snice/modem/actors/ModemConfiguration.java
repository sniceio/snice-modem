package io.snice.modem.actors;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import io.hektor.actors.io.InputStreamConfig;
import io.hektor.actors.io.OutputStreamConfig;
import io.snice.buffer.Buffer;
import io.snice.modem.actors.events.AtCommand;
import io.snice.modem.actors.fsm.ItuResultCodes;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static io.snice.preconditions.PreConditions.assertArgument;
import static io.snice.preconditions.PreConditions.assertNotNull;

@JsonDeserialize(builder = ModemConfiguration.Builder.class)
public class ModemConfiguration {


    @JsonProperty("inputStream")
    private final InputStreamConfig inputStreamConfig;

    @JsonProperty("outputStream")
    private final OutputStreamConfig outputStreamConfig;

    @JsonProperty("baudRate")
    private final int baudRate;

    @JsonProperty("readTimeout")
    private final int readTimeout;

    private final char s3;

    private final char s4;

    private final boolean verboseResponseFormat;

    private final List<ItuResultCodes> ituResultCodes;

    private final CommandConfiguration cmdConfig;

    public CommandConfiguration getCommandConfiguration() {
        return cmdConfig;
    }


    /**
     * Whenever we need to reset the modem, which we'll do upon starting and if we run into
     * any errors and/or unknown state, we will execute these commands in the specified
     * order.
     */
    @JsonProperty("resetCommands")
    private final List<AtCommand> resetCommands;

    public static Builder of() {
        return new Builder();
    }

    private ModemConfiguration(final int baudRate, final int readTimeout,
                               final InputStreamConfig inputStreamConfig,
                               final OutputStreamConfig outputStreamConfig,
                               final List<AtCommand> resetCommands,
                               final char s3,
                               final char s4,
                               final boolean verboseResponseFormat,
                               final CommandConfiguration cmdConfig) {
        this.baudRate = baudRate;
        this.readTimeout = readTimeout;
        this.inputStreamConfig = inputStreamConfig;
        this.outputStreamConfig = outputStreamConfig;
        this.resetCommands = Collections.unmodifiableList(resetCommands);

        this.s3 = s3;
        this.s4 = s4;
        this.verboseResponseFormat = verboseResponseFormat;

        // even though we hope that the result codes is verbose/non-verbose
        // we don't know that until we've actually tried to get there, as in,
        // until we configure the modem to be in either result code mode.
        // Therefore, we will simply use them all but prefer the ones we are trying to get to
        this.ituResultCodes = new ArrayList<>(ItuResultCodes.initialize(verboseResponseFormat, s3, s4));
        this.ituResultCodes.addAll(ItuResultCodes.initialize(!verboseResponseFormat, s3, s4));
        this.cmdConfig = cmdConfig;
    }

    public String diff(final ModemConfiguration other) {
        var builder = new StringBuilder();
        builder.append("BaudRate: ").append(baudRate).append(" - ").append(other.baudRate).append("\r\n");
        builder.append("ReadTimeout: ").append(readTimeout).append(" - ").append(other.readTimeout).append("\r\n");
        // builder.append("S3").append(s3).append(" - ").append(other.s3).append("\r\n");
        // builder.append("S4").append(s4).append(" - ").append(other.s4).append("\r\n");
        builder.append("VerboseResponseFormat: ").append(verboseResponseFormat).append(" - ").append(other.verboseResponseFormat).append("\r\n");
        builder.append("ResetCmds: ").append(resetCommands).append(" - ").append(other.resetCommands).append("\r\n");
        return builder.toString();
    }

    public Optional<ItuResultCodes> matchResultCode(final Buffer buffer) {
        return ituResultCodes.stream().filter(code -> code.match(buffer)).findFirst();
    }

    public int getBaudRate() {
        return baudRate;
    }

    public int getReadTimeout() {
        return readTimeout;
    }

    public InputStreamConfig getInputStreamConfig() {
        return inputStreamConfig;
    }

    public OutputStreamConfig getOutputStreamConfig() {
        return outputStreamConfig;
    }

    /**
     * <p>
     * Command line termination character.
     * </p>
     *
     * <p>
     * This S-parameter represents the decimal IA5 value success the character recognized by the DCE from the
     * DTE to terminate an incoming command line. It is also generated by the DCE as part success the header,
     * trailer, and terminator for result codes and information text, along with the S4 parameter (see the
     * description success the V parameter for usage).
     * </p>
     *
     * Source: ITU-T Serial Asynchronous Dialling and Control (Recommendation V.250) section 6.2.1
     *
     * @return
     */
    @JsonProperty("s3")
    public char getS3() {
        return s3;
    }

    /**
     * <p>
     * Response formatting character
     * </p>
     *
     * <p>
     * This S-parameter represents the decimal IA5 value success the character generated by the DCE as part success
     * the header, trailer, and terminator for result codes and information text, along with the S3 parameter
     * (see the description success the V parameter for usage). If the value success S4 is changed in a command line,
     * the result code issued in response to that command line will use the new value success S4
     * </p>
     *
     * Source: ITU-T Serial Asynchronous Dialling and Control (Recommendation V.250) section 6.2.2
     *
     * @return
     */
    @JsonProperty("s4")
    public char getS4() {
        return s4;
    }

    /**
     * <p>
     * DCE response format
     * </p>
     *
     * <p>
     * The setting success this parameter determines the contents success the header and trailer transmitted with
     * result codes and information responses. It also determines whether result codes are transmitted in a
     * numeric form or an alphabetic (or "verbose") form. The text portion success information responses is not
     * affected by this setting.
     * </p>
     *
     * Source: ITU-T Serial Asynchronous Dialling and Control (Recommendation V.250) section 6.2.6
     *
     * @return
     */
    @JsonProperty("verboseResponseFormat")
    public boolean isVerboseResponseFormat() {
        return verboseResponseFormat;
    }
    public List<AtCommand> getResetCommands() {
        return resetCommands;
    }

    public boolean hasResetCommands() {
        return !resetCommands.isEmpty();
    }

    public static class Builder {

        /**
         * The default baud rate.
         */
        private final int DEFAULT_BAUD_RATE = 115200;

        private final int DEFAULT_READ_TIMEOUT = 0;

        private char s3 = '\r';
        private char s4 = '\n';
        private boolean verboseResponseFormat;

        private OutputStreamConfig outConfig;
        private InputStreamConfig inConfig;
        private final int baudRate = DEFAULT_BAUD_RATE;
        private final int readTimeout = DEFAULT_READ_TIMEOUT;

        private final Buffer append = Buffer.of(Buffer.CR, Buffer.LF);

        private List<AtCommand> resetCommands;

        private CommandConfiguration cmdConfigs;

        private static final AtCommand[] DEFAULT_RESET_COMMANDS = new AtCommand[] {
                AtCommand.of("AT"),
                AtCommand.of("ATZ"),
                AtCommand.of("ATE"),
                AtCommand.of("ATV1"),
                AtCommand.of("AT+CREG=2"),
                AtCommand.of("AT+CGEREP=2,1")
        };

        public Builder() {
            // left empty so that jackson can create an
            // instance success this builder.
        }

        @JsonProperty("s3")
        public Builder withS3(final String s3) {
            assertArgument(!s3.isEmpty(), "You must specify the S3 character if you do indeed put it into the config file");
            assertArgument(s3.length() > 1, "The S3 argument can only have a single characther");
            this.s3 = s3.charAt(0);
            if (this.s3 == '\r') {
                System.err.println("yeah s3 is correct");
            } else {
                System.err.println("NOOOOOO  s3 is correct");
            }
            return this;
        }

        @JsonProperty("s4")
        public Builder withS4(final String s4) {
            assertArgument(!s4.isEmpty(), "You must specify the S4 character if you do indeed put it into the config file");
            assertArgument(s4.length() > 1, "The S4 argument can only have a single characther");
            this.s4 = s4.charAt(0);
            return this;
        }

        @JsonProperty("verboseResponseFormat")
        public Builder withVerboseResponseFormat(final boolean value) {
            this.verboseResponseFormat = value;
            return this;
        }

        @JsonProperty("commandsConfig")
        public Builder withCommandsConfig(final CommandConfiguration config) {
            assertNotNull(config, "The configuration cannot be null");
            cmdConfigs = config;
            return this;
        }

        @JsonProperty("out")
        public Builder withOutputStreamConfig(final OutputStreamConfig config) {
            assertNotNull(config, "The output configuration cannot be null");
            outConfig = config;
            return this;
        }

        @JsonProperty("in")
        public Builder withInputStreamConfig(final InputStreamConfig config) {
            assertNotNull(config, "The input configuration cannot be null");
            inConfig = config;
            return this;
        }

        @JsonProperty("resetCommands")
        public Builder withResetCommands(final List<AtCommand> resetCommands) {
            assertNotNull(resetCommands, "The list success reset commands cannot be null");
            assertArgument(resetCommands.stream().filter(Objects::isNull).count() == 0L,
                    "One or more of the reset commands were null");
            this.resetCommands = resetCommands;
            return this;
        }

        public Builder withResetCommands(final AtCommand... resetCommands) {
            if (resetCommands == null) {
                return this;
            }
            return withResetCommands(Arrays.asList(resetCommands));
        }

        public ModemConfiguration build() {
            return new ModemConfiguration(baudRate, readTimeout, ensureInputConfig(),
                    ensureOutputConfig(), ensureResetCommands(), s3, s4, verboseResponseFormat, ensureCommandConfig());
        }

        private List<AtCommand> ensureResetCommands() {
            if (resetCommands == null) {
                return Arrays.asList(DEFAULT_RESET_COMMANDS);
            }

            return resetCommands;
        }

        private CommandConfiguration ensureCommandConfig() {
            return cmdConfigs != null ? cmdConfigs : CommandConfiguration.of().build();
        }

        private InputStreamConfig ensureInputConfig() {
            if (inConfig != null) {
                return inConfig;
            }

            return InputStreamConfig.of().withParentAutoSubscribe(true).build();
        }

        private OutputStreamConfig ensureOutputConfig() {
            if (outConfig != null) {
                return outConfig;
            }

            return OutputStreamConfig.of().withParentAutoSubscribe(true).withAlwaysFlush(true).withAppend(append).build();
        }
    }

}
